#include "doodson.hpp"
#include "eop.hpp"
#include <array>
#include <cmath>

namespace {
  struct Table51aData {
    /* Doodson numbers from IERS 2010, Table 5.1a */
    dso::DoodsonConstituent dn;
    /* cooresponding Coefficients of sin(argument) and cos(argument), 
     * IERS 2010, Table 5.1a 
     */
    double xs,xc,ys,yc;
  };
  constexpr const std::array<Table51aData, 10/*26*/> Table = {{
      //{{+0, +0, +0, +0, +1, +0},
      // +0.000e+00,
      // +6.000e-01,
      // -1.000e-01,
      // -1.000e-01}, /*   6798.38*/
      //{{+0, +0, +0, +1, -1, +0},
      // +1.500e+00,
      // +0.000e+00,
      // -2.000e-01,
      // +1.000e-01}, /*   6159.14*/
      //{{+0, +0, +0, +1, +0, +0},
      // -2.850e+01,
      // -2.000e-01,
      // +3.400e+00,
      // -3.900e+00}, /*   3231.50*/
      //{{+0, +0, +0, +1, +1, +0},
      // -4.700e+00,
      // -1.000e-01,
      // +6.000e-01,
      // -9.000e-01}, /*   2190.35*/
      //{{+0, +0, +1, -1, -1, -1},
      // -7.000e-01,
      // +2.000e-01,
      // -2.000e-01,
      // -7.000e-01}, /*    438.36*/
      //{{+0, +0, +1, -1, +0, -1},
      // +1.000e+00,
      // +3.000e-01,
      // -3.000e-01,
      // +1.000e+00}, /*    411.81*/
      //{{+0, +0, +1, +0, +0, +0},
      // +1.200e+00,
      // +2.000e-01,
      // -2.000e-01,
      // +1.400e+00}, /*    365.24*/
      //{{+0, +0, +2, -1, +0, +0},
      // +1.300e+00,
      // +4.000e-01,
      // -2.000e-01,
      // +2.900e+00}, /*    193.56*/
      //{{+0, +1, +0, +0, -1, +0},
      // -1.000e-01,
      // -2.000e-01,
      // +0.000e+00,
      // -1.700e+00}, /*     27.43*/
      //{{+0, +1, +0, +0, +0, +0},
      // +9.000e-01,
      // +4.000e+00,
      // -1.000e-01,
      // +3.240e+01}, /*     27.32*/
      //{{+0, +1, +0, +0, +1, +0},
      // +1.000e-01,
      // +6.000e-01,
      // +0.000e+00,
      // +5.100e+00}, /*     27.21*/
      //{{+0, +2, -2, +1, +0, +0},
      // +0.000e+00,
      // +1.000e-01,
      // +0.000e+00,
      // +6.000e-01}, /*     14.70*/
      //{{+0, +2, +0, -1, +0, +0},
      // -1.000e-01,
      // +3.000e-01,
      // +0.000e+00,
      // +2.700e+00}, /*     13.72*/
      //{{+0, +3, +0, +0, +0, +0},
      // -1.000e-01,
      // +1.000e-01,
      // +0.000e+00,
      // +9.000e-01}, /*      9.11*/
      //{{+0, +3, +0, +0, +1, +0},
      // -1.000e-01,
      // +1.000e-01,
      // +0.000e+00,
      // +6.000e-01}, /*      9.10*/
      {{+1, -2, +0, +1, -1, +0},
       -4.000e-01,
       +3.000e-01,
       -3.000e-01,
       -4.000e-01}, /*      1.12*/
      {{+1, -2, +0, +1, +0, +0},
       -2.300e+00,
       +1.300e+00,
       -1.300e+00,
       -2.300e+00}, /*      1.12*/
      {{+1, -2, +2, -1, +0, +0},
       -4.000e-01,
       +3.000e-01,
       -3.000e-01,
       -4.000e-01}, /*      1.11*/
      {{+1, -1, +0, +0, -1, +0},
       -2.100e+00,
       +1.200e+00,
       -1.200e+00,
       -2.100e+00}, /*      1.08*/
      {{+1, -1, +0, +0, +0, +0},
       -1.140e+01,
       +6.500e+00,
       -6.500e+00,
       -1.140e+01}, /*      1.08*/
      {{+1, +0, +0, +1, +0, +0},
       +8.000e-01,
       -5.000e-01,
       +5.000e-01,
       +8.000e-01}, /*      1.03*/
      {{+1, +1, -2, +0, +0, +0},
       -4.800e+00,
       +2.700e+00,
       -2.700e+00,
       -4.800e+00}, /*      1.00*/
      {{+1, +1, +0, +0, +0, +0},
       +1.430e+01,
       -8.200e+00,
       +8.200e+00,
       +1.430e+01}, /*      1.00*/
      {{+1, +1, +0, +0, +1, +0},
       +1.900e+00,
       -1.100e+00,
       +1.100e+00,
       +1.900e+00}, /*      1.00*/
      {{+1, +2, +0, -1, +0, +0},
       +8.000e-01,
       -4.000e-01,
       +4.000e-01,
       +8.000e-01}, /*      0.96*/
  }};               /* Table */

  /* Rate of secular polar motion (Âµas/y) due to the zero frequency tide */
  [[maybe_unused]]constexpr const double xrate = -3.8e0;
  [[maybe_unused]]constexpr const double yrate = -4.3e0;
} /* unnamed namespace */

int dso::xypole_libration(const double *const fargs, double gmst, double &xp,
                      double &yp) noexcept {
  /* get Doodson arguments from Delaunay arguments and GMST */
  double dargs[6];
  dso::delaunay2doodson(fargs, gmst, dargs);
  /* these will never change */
  const double *__restrict__ f = dargs;

  /* set corrections to zero */
  xp = yp = 0e0;
  for (const auto &entry : Table) {
    const double arg = entry.dn.argument(f);
    const double sa = std::sin(arg);
    const double ca = std::cos(arg);
    xp += sa * entry.xs + ca * entry.xc; /* microarcseconds */
    yp += sa * entry.ys + ca * entry.yc; /* microarcseconds */
  }

  return 0;
}
