#include "iers2010.hpp"
#include <stdexcept>
#include <iostream>
#include <fstream>
    
constexpr int nl   { 600 };
constexpr int nt   { 342 };
constexpr int ntin { 11  };

int
read_hardisp_args(double tamp[3][ntin], double tph[3][ntin],
    const char* filename=nullptr)
{
    std::istream* in;
    std::ifstream ifn;
    char line[256];

    if ( !filename ) {
        in = &std::cin;
    } else {
        ifn.open( filename );
        in = &ifn;
    }

    /*---------------------------------------------------------------------
     *  Read in amplitudes and phases, in standard "Scherneck" form, from
     *  standard input
     *----------------------------------------------------------------------*/
    while ( true ) {
        for (int i=0; i<3; i++) {
            for (int kk=0; kk<ntin; kk++) {
                if ( !in->getline(line, 256) ) {
                    return 1;
                } else { //TODO
                    std::cin >> tamp[i][kk];
                }
            }
        }

    for (int i=0; i<3; i++) {
        for (int kk=0; kk<ntin; kk++) {
            std::cin >> tph[i][kk];
        }
        // Change sign for phase, to be negative for lags
        for (int kk=0; kk<ntin; kk++) {
            tph[i][kk] = -tph[i][kk];
        }
    }
    if ( !std::cin || std::cin.fail() ) {
        printf ("\nError reading data lines. Exiting ...\n");
        return 1;
    }
}

/**
 * \details This program reads in a file of station displacements in the BLQ
 *          format used by Scherneck and Bos for ocean loading, and outputs a
 *          time series of computed tidal displacements, using an expanded set
 *          of tidal constituents, whose amplitudes and phases are found by
 *          spline interpolation of the tidal admittance.  A total of 342
 *          constituent tides are included, which gives a precision of about
 *          0.1%.
 *          This function is a translation/wrapper for the fortran HARDISP
 *          subroutine, found here : 
 *          http://maia.usno.navy.mil/conv2010/software.html
 *
 * \param[in] argc   Number of command line arguments (Note 3)
 * \param[in] argv[] Command line arguments; these are read from stdin in the
 *                   following order (Note 3):
 *                   -# year (integer) (Note 4)
 *                   -# [month (integer) day_of_month (integer)], or 
 *                      day_of_year (integer)
 *                   -# hour (integer)
 *                   -# minute (integer)
 *                   -# second (integer)
 *                   -# Number of output epochs to be written out/computed 
 *                      (integer)
 *                   -# Sampling interval (in seconds) (double)
 *                   -# Ocean loading coefficients in 'blq' format
 * \return           An integer denoting the exit status:
 *                   Returned Value  | Function Status
 *                   ----------------|-------------------------------------
 *                                 0 | Sucess
 * 
 * \note
 *     -# The input ocean loading coefficients were generated by the ocean 
 *        loading service on 25 June 2009 using 
 *        http://www.oso.chalmers.se/~loading/ for IGS stations Onsala and 
 *        Reykjavik using the CSR4.0 model and "NO" geocenter correction.
 *     -# The site displacement output is written to standard output with the 
 *        format 3F14.6. All units are expressed in meters. The numbers written
 *        correspong to: <br>
 *        du : Radial tidal ocean loading displacement,<br>
 *        dw : West tidal ocean loading displacement,<br>
 *        ds : South tidal ocean loading displacement
 *     -# \c argv and \c argc are read from stdin (like in every 'main'). Date
 *       provided, must be in UTC scale.
 *     -# Status:  Class 1 model
 * 
 * \warning \b IMPORTANT <br>
 *     A new version of this routine must be
 *     produced whenever a new leap second is
 *     announced.  There are three items to
 *     change on each such occasion:<br>
 *     1) Update the nstep variable<br>
 *     2) Update the arrays st and si<br>
 *     3) Change date of latest leap second<br>
 *     <b>Latest leap second:  2016 December 31</b>
 * 
 * \version 19.12.2016
 * 
 * \cite iers2010
 * 
 */
int
hardisp_impl(int irnt, double samp, double tamp[3][ntin], double tph[3][ntin])
{
    /*+---------------------------------------------------------------------
     *
     *  Parameters below set the buffer size for computing the tides
     *  recursively (nl), the number of harmonics used in the prediction
     *  (nt; this must also be set in the subroutine admint) and the number
     *  of harmonics read in (ntin)
     *
     *----------------------------------------------------------------------*/
    constexpr int nl   ( 600 );
    constexpr int nt   ( 342 );
    constexpr int ntin ( 11 );

    constexpr double dr ( 0.01745329252e0 );
    int irli  ( 1 );
    int it[5];

    #ifdef USE_EXTERNAL_CONSTS
        constexpr double PI (DPI);
    #else
        constexpr double PI ( 3.1415926535897932384626433e0 );
    #endif

    //  Cartwright-Tayler numbers of tides used in Scherneck lists:
    //+     M2, S2, N2, K2, K1, O1, P1, Q1, Mf, Mm, Ssa
    constexpr int idt[][6] = {
        {2, 0, 0, 0, 0, 0},
        {2, 2,-2, 0, 0, 0},
        {2,-1, 0, 1, 0, 0},
        {2, 2, 0, 0, 0, 0},
        {1, 1, 0, 0, 0, 0},
        {1,-1, 0, 0, 0, 0},
        {1, 1,-2, 0, 0, 0},
        {1,-2, 0, 1, 0, 0},
        {0, 2, 0, 0, 0, 0},
        {0, 1, 0,-1, 0, 0},
        {0, 0, 2, 0, 0, 0}
    };

    
    /*+---------------------------------------------------------------------
     *
     *  Find amplitudes and phases for all constituents, for each of the
     *  three displacements. Note that the same frequencies are returned 
     *  each time.
     *
     *  BLQ format order is vertical, horizontal EW, horizontal NS
     *
     *----------------------------------------------------------------------*/
    double az[nt],pz[nt],f[nt],aw[nt],pw[nt],as[nt],ps[nt];
    int    ntout;
    double amp[ntin], phase[ntin];
    
    for (int i=0;i<ntin;i++) {
        amp[i]   = tamp[0][i];
        phase[i] = tph[0][i];
    }
    iers2010::hisp::admint (amp,idt,phase,az,f,pz,ntin,ntout,it);

    for (int i=0;i<ntin;i++) {
        amp[i] = tamp[1][i];
        phase[i] = tph[1][i];
    }
    iers2010::hisp::admint (amp,idt,phase,aw,f,pw,ntin,ntout,it);

    for (int i=0;i<ntin;i++) {
        amp[i] = tamp[2][i];
        phase[i] = tph[2][i];
    }
    iers2010::hisp::admint (amp,idt,phase,as,f,ps,ntin,ntout,it);

    // set up for recursion, by normalizing frequencies, and converting
    // phases to radians
    double wf[nt];
    for (int i=0;i<ntout;i++) {
        pz[i] = dr * pz[i];
        ps[i] = dr * ps[i];
        pw[i] = dr * pw[i];
        f[i]  = samp * PI * f[i]/43200.e0;
        wf[i] = f[i];
    }
    
    /*+---------------------------------------------------------------------
     *
     *  Loop over times, nl output points at a time. At the start of each
     *  such block, convert from amp and phase to sin and cos (hc array) at
     *  the start of the block. The computation of values within each
     *  block is done recursively, since the times are equi-spaced.
     *
     *----------------------------------------------------------------------*/
    while ( true ) {
        int irhi ( std::min (irli+nl-1,irnt) );
        int np   ( irhi - irli + 1 );

        // Set up harmonic coefficients, compute tide, and write out
        double hcz[2*nt+1],hcs[2*nt+1],hcw[2*nt+1];
        for (int i=0;i<nt;i++) {
            hcz[2*i] = az[i] * cos (pz[i]);
            hcz[2*i+1]  = -az[i] * sin (pz[i]);
            hcs[2*i] = as[i] * cos (ps[i]);
            hcs[2*i+1]  = -as[i] * sin (ps[i]);
            hcw[2*i] = aw[i] * cos (pw[i]);
            hcw[2*i+1]  = -aw[i] * sin (pw[i]);
        }

        double dz[nl],ds[nl],dw[nl];
        double scr[3*nt];
        iers2010::hisp::recurs (dz,np,hcz,ntout,wf,scr);
        iers2010::hisp::recurs (ds,np,hcs,ntout,wf,scr);
        iers2010::hisp::recurs (dw,np,hcw,ntout,wf,scr);

        for (int i=0;i<np;i++)
            printf ("\n%14.6f %14.6f %14.6f",dz[i],ds[i],dw[i]);
        printf ("\n");

        if (irhi==irnt)
            break;

        irli = irhi + 1;

        // Reset phases to the start of the new section
        for (int i=0;i<nt;i++) {
            pz[i] = fmod (pz[i] + np * f[i],2.e0*PI);
            ps[i] = fmod (ps[i] + np * f[i],2.e0*PI);
            pw[i] = fmod (pw[i] + np * f[i],2.e0*PI);
        }
    }

    return 0;
}

int
main(int argc, char* argv[])
{
    /*+----------------------------------------------------------------------
     *  Check number of arguments from command line, then read them in
     *-----------------------------------------------------------------------*/
    if (argc<8 || argc>9) {
        printf(" Usage:\n");
        printf("   hardisp yr [d-of-yr | month day] hr min sec num samp\n");
        printf(" Where \n");
        printf("   the UTC date given is the time of the first term output\n");
        printf("   num is the number of output epochs to be written out\n");
        printf("   samp is the sample interval (seconds)\n");
        printf(" The harmonics file (amp and phase of displacement) is \n");
        printf("   read from standard input in the BLQ format used by  \n");
        printf("   Scherneck and Bos\n");
        printf(" Results are written to standard output (units = m):\n");
        printf("      dU    dS    dW   \n");
        printf("   using format: 3F14.6 \n");
        return 1;
    }

    int next = 1;
    int irnt;
    double samp;
    try {
        *it = std::stoi(argv[next++]);
        if (argc == 7) { /* day of year provided */
            it[1] = std::stoi(argv[next++]);
        } else { /* month - day of month provided */
            int month = std::stoi(argv[next++]);
            int dom   = std::stoi(argv[next++]);
            it[1]     = dom + iers2010::hisp::mday(it[0], month);
        }
        it[2] = std::stoi(argv[next++]);
        it[3] = std::stoi(argv[next++]);
        it[4] = (int) std::stof (argv[next++]);
        irnt  = std::stoi(argv[next++]);
        samp  = std::stod(argv[next++]);
    } catch (std::invalid_argument&) {
        std::cerr<<"Invalid argument while reading input arguments. Fatal.\n";
        return 1;
    } catch (std::out_of_range&) {
        std::cerr<<"Invalid argument while reading input arguments. Fatal.\n";
        return 1;
    }

    /// Read in ocean loading coefficients from stdin
    double tamp[3][ntin],
           tph[3][ntin];
    if (read_hardisp_args(tamp[3][ntin], tph[3][ntin])) {
        std::cerr<<"Failed to read harmonics. Fatal.\n";
        return 1;
    }

    // Compute & report
    return hardisp_impl(irnt, samp, tamp, tph);
}

