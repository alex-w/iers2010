#include <vector>
#include <string>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <cstring>
#include <charconv>
#include "eigen3/Eigen/Eigen"
#include "tide_atlas.hpp"
#include "icgemio.hpp"
#include <stdexcept>
#include <set>


/* References:
 *
 * [1] Torsten Mayer-Gürr and Felix Öhlinger, Gravitational effect of ocean and 
 * atmospheric tides, Graz University of Technology, Institute of Geodesy, 
 * Graz, Austria. Available at: 
 * https://ftp.tugraz.at/outgoing/ITSG/oceanAndAtmosphericTides/README.pdf
 */

namespace {
/* given a file that contains two-column string, seperated by whitespace(s), 
 * resolve them and return them in a vector of strings. 
 *
 * File example:
 * TiME22_ATM_162.556_pi1_cos.gfc TiME22_ATM_162.556_pi1_sin.gfc 
 * TiME22_ATM_163.555_p1_cos.gfc TiME22_ATM_163.555_p1_sin.gfc 
 * TiME22_ATM_164.556_s1_cos.gfc TiME22_ATM_164.556_s1_sin.gfc 
 * TiME22_ATM_165.555_k1_cos.gfc TiME22_ATM_165.555_k1_sin.gfc 
 * TiME22_ATM_166.554_psi1_cos.gfc TiME22_ATM_166.554_psi1_sin.gfc 
 * TiME22_ATM_255.555_m2_cos.gfc TiME22_ATM_255.555_m2_sin.gfc 
 * TiME22_ATM_272.556_t2_cos.gfc TiME22_ATM_272.556_t2_sin.gfc 
 * 
 * returns a vector<string> with elements:
 * TiME22_ATM_162.556_pi1_cos.gfc
 * TiME22_ATM_162.556_pi1_sin.gfc
 * TiME22_ATM_163.555_p1_cos.gfc
 * TiME22_ATM_163.555_p1_sin.gfc
 * TiME22_ATM_164.556_s1_cos.gfc
 * TiME22_ATM_164.556_s1_sin.gfc
 * TiME22_ATM_165.555_k1_cos.gfc
 * TiME22_ATM_165.555_k1_sin.gfc
 * TiME22_ATM_166.554_psi1_cos.gfc
 * TiME22_ATM_166.554_psi1_sin.gfc
 * TiME22_ATM_255.555_m2_cos.gfc
 * [...]
 *
 * This function is normally used to parse a file of type:
 * <model>_001fileList.txt
 * generated by Graz University of Technology, Institute of Geodesy via 
 * GROOPS. See [1]
 *
 * @param[in] fn Filename
 * @return A vector of string, i.e. the filenames recorded/parsed in the file.
 */
std::vector<std::string> resolve_file_list(const char *fn) noexcept {
  std::ifstream fin(fn);
  if (!fin.is_open()) {
    fprintf(stderr, "[ERROR] Failed opening file %s (traceback: %s)\n", fn,
            __func__);
    return std::vector<std::string>{};
  }

  std::vector<std::string> fnvec;
  constexpr const int LSZ = 512;
  char line[LSZ];
  while (fin.getline(line, LSZ)) {
    const char *str1 = line;
    while (*str1 && *str1==' ') ++str1;
    const char *end1 = str1;
    while (*end1 && *end1!=' ') ++end1;
    const char *str2 = end1;
    while (*str2 && *str2==' ') ++str2;
    const char *end2 = str2;
    while (*end2 && *end2!=' ') ++end2;
    std::string sline(line);
    fnvec.emplace_back(sline.substr(str1-line, end1-str1));
    fnvec.emplace_back(sline.substr(str2-line, end2-str2));
  }
  return fnvec;
}

const char *skipws(const char *line) noexcept {
  while (*line && *line == ' ') ++line;
  return line;
}

[[maybe_unused]]
std::vector<std::array<int,6>> resolve_doodson(const char *fn) noexcept {
  std::ifstream fin(fn);
  if (!fin.is_open()) {
    fprintf(stderr, "[ERROR] Failed opening file %s (traceback: %s)\n", fn,
            __func__);
    return std::vector<std::array<int,6>>{};
  }

  std::vector<std::array<int,6>> dvec;
  constexpr const int LSZ = 124;
  char line[LSZ];
  int error = 0;
  while (fin.getline(line, LSZ) && (!error)) {
    std::array<int,6> ar;
    auto sz = std::strlen(line);
    const char *str = line;
    for (int i=0; i<6; i++) {
      auto res = std::from_chars(skipws(str), str+sz, ar[i]);
      error += (res.ec != std::errc{});
      str = res.ptr;
    }
    dvec.emplace_back(ar);
  }

  if (error) {
    fprintf(stderr, "[ERROR] Failed resolving Doodson numbers from file %s (traceback: %s)\n", fn, __func__);
    return std::vector<std::array<int,6>>{};
  }

  return dvec;
}

[[maybe_unused]]
int parse_admittance(const char *fn, Eigen::MatrixXd &mat) noexcept {
  std::ifstream fin(fn);
  if (!fin.is_open()) {
    fprintf(stderr, "[ERROR] Failed opening file %s (traceback: %s)\n", fn,
            __func__);
    return 1;
  }

  const int rows = mat.rows();
  const int cols = mat.cols();

  constexpr const int LSZ = 1024;
  char line[LSZ];
  int error = 0;
  int row = 0;

  while (fin.getline(line, LSZ) && (!error)) {
    if (row > rows) {
      fprintf(stderr,
              "[ERROR] More rows than expected in admittance file %s "
              "(traceback: %s)\n",
              fn, __func__);
      return 1;
    }
    auto sz = std::strlen(line);
    const char *str = line;
    for (int col = 0; col < cols; col++) {
      auto res = std::from_chars(skipws(str), str + sz, mat(row, col));
      error += (res.ec != std::errc{});
      str = res.ptr;
    }
    ++row;
  }

  if (error) {
    fprintf(
        stderr,
        "[ERROR] Failed resolving admittance from file %s (traceback: %s)\n",
        fn, __func__);
    return 1;
  }

  return 0;
}

struct GroopsTideModelFileName {
  char _model[48]={"\0"};
  dso::DoodsonConstituent _doodson;
  char _constituentName[16]={"\0"};
  char _sinCos; /* 'c' or 's' */

  std::string compile(const char *model_name=nullptr, const dso::DoodsonConstituent *dood=nullptr, const char *wave_name=nullptr, char sincos='s') const noexcept {
    const char *m = (model_name == nullptr)?_model:model_name;
    char buf[16] = {'\0'};
    const dso::DoodsonConstituent *d = (dood==nullptr)?(&_doodson):(dood);
    d->str(buf, true);
    const char *w = (wave_name==nullptr)?_constituentName:wave_name;
    char str[124] = {'\0'};
    std::sprintf(str, "%s_%s_%s_%s.gfc", m, buf, w, (sincos=='c')?"sin":"cos");
    return std::string(str);
  }

  GroopsTideModelFileName(const char *fn) {
    int error = 0;
    /* pattern is <model name>_<doodson>_<name>_<cos/sin>.gfc */
    const int sz = std::strlen(fn);
    /* start backwards; check extension fn[sz-4:sz] == .gfc */
    if (std::strncmp(fn+sz-4, ".gfc", 4)) ++error;
    
    /* check sin/cos fn[sz-7] == sin/cos */
    {
      if (std::strncmp(fn + sz - 7, "sin", 3)) {
        if (std::strncmp(fn + sz - 7, "cos", 3)) {
          ++error;
        } else {
          _sinCos = 'c';
        }
      } else {
        _sinCos = 's';
      }
    }

    /* get name of harmonic */
    int lastchar = sz - 9; /* should be just be before '_[sin|cos]' */
    {
      const char *str = fn + lastchar;
      while (*str && *str != '_')
        --str;
      std::memcpy(_constituentName, str+1, fn + sz - 9 - str);
      lastchar = str - fn;
    }

    /* get Doodson */
    {
      const char *str = fn + lastchar - 1;
      while (*str && *str != '_')
        --str;
      _doodson = dso::DoodsonConstituent::from_chars(str+1);
      lastchar = str-fn;
    }

    /* the rest is the model name */
    std::memcpy(_model, fn, lastchar);

    if (error) {
      fprintf(stderr, "[ERROR] Failed parsing tidal constituent filename %s, part of some tide atlas (traceback: %s)\n", fn, __func__);
      throw std::runtime_error("[ERROR] Failed parsing gfc constituent filename\n");
    }
  }
}; /* GroopsTideModelFileName */

/** @brief Validate a file list extracted from a <MODEL>_001fileList.txt file.
 *
 * Validate means:
 * 1. make sure we have no duplicates,
 * 2. make sure for every sin file there is a corresponding cos file
 */
int validate_file_list(const std::vector<std::string> &file_list) noexcept {
  /* search for duplicates */
  std::set<std::string> file_set(file_list.begin(), file_list.end());
  if (file_list.size() != file_set.size()) {
      fprintf(stderr, "[WRNNG] Duplicate entry/ies found in file list (traceback: %s)\n", __func__);
      return 1;
  }
  for (const auto &f : file_list) {
    /* search for the corresponding trig */
    const GroopsTideModelFileName gfn(f.c_str());
    const std::string fr = gfn.compile(nullptr, nullptr, nullptr, (gfn._sinCos=='s')?'c':'s');
    auto resit = std::find_if(file_list.cbegin(), file_list.cend(), [&](const std::string &s){ return s==fr; });
    if (resit == file_list.cend()) {
      fprintf(stderr, "[WRNNG] Failed locating respective coeff file for %s, i.e. %s (traceback: %s)\n", f.c_str(), fr.c_str(), __func__);
      return 2;
    }
  }
  return 0;
}

} /* unnamed namespace */

dso::TideAtlas dso::groops_atlas(const char *file_list,
const char *dir,
                           int max_degree,
                           int max_order) {

  /* parse file list from <model>_001_fileList.txt */
  const auto flvec = resolve_file_list(file_list);
  if (flvec.size() < 1) {
    fprintf(stderr,
            "[ERROR] Failed parsing file list from file %s; cannot create tidal atlas (traceback: %s)\n",
            file_list, __func__);
    throw std::runtime_error("[ERROR] Failed resolving tide atlas file list\n");
  }

  if (flvec.size() % 2) {
    fprintf(stderr,
            "[ERROR] Expected even number of files in input file %s, found %ld "
            "(traceback: %s)\n",
            file_list, flvec.size(), __func__);
    throw std::runtime_error("[ERROR] Incorrect number of input file in atlas file list\n");
  }

  /* validate the file list */
  if (validate_file_list(flvec)) {
    fprintf(stderr, "[ERROR] Seems that the file list in %s is corrupt! (traceback: %s)\n", file_list, __func__);
    throw std::runtime_error("[ERROR] Failed parsing tidal wave file list\n");
  }

  /* Create a new (empty) TidalAtlas instance */
  dso::TideAtlas atlas;

  char tmp_name[dso::TideAtlas::NAME_MAX_CHARS] = {'\0'};
  int cmaxdeg = (max_degree < 0)?120:max_degree;
  int cmaxord = (max_order < 0)?120:max_order;
  /* iterate through input files (waves) and read/parse coefficients for each 
   * of the k waves of the atlas
   */
  for (const auto &wave_fn : flvec) {
    /* resolve filename */
    GroopsTideModelFileName wave_info(wave_fn.c_str());

    /* check if we already have the tidal wave in the atlas */
    auto it = atlas.find_tidal_wave(wave_info._doodson);

    if (it == atlas.waves().end()) {
      /* new tidal wave */
      it = atlas.append_wave(dso::TidalWave(wave_info._doodson, 0e0, 0e0,
                                            wave_info._constituentName),
                             (max_degree < 0) ? cmaxdeg : max_degree,
                             (max_order < 0) ? cmaxord : max_order);
      it = atlas.waves().end() - 1;
    } else {
      /* tidal wave already exists */
      ;
    }

    char cfilename[248];
    {
      /* construct full filename, including path */
      std::strcpy(cfilename, dir);
      #ifdef _WIN32
      std::strcat(cfilename, "\\");
#else
      std::strcat(cfilename, "/");
#endif
      std::strcat(cfilename, wave_fn.c_str());
    }
    
    /* an Icgem instance to read data from (Stokes coefficients) */
    dso::Icgem icgem(cfilename);
    //if (tmp_name[0] && std::strcmp(tmp_name, icgem.model_name())) {
    //  fprintf(stderr,
    //          "[WRNNG] Model name in file %s differs from previous files, i.e. "
    //          "%s vs %s (traceback: %s)\n",
    //          wave_fn.c_str(), icgem.model_name(), tmp_name, __func__);
    //}
    std::strcpy(tmp_name, icgem.model_name());

    /* read coefficients to sin/cos part */
    dso::StokesCoeffs *cs =
      (wave_info._sinCos == 's') ? &(it->stokes_sin()) : &(it->stokes_cos());

    if (icgem.parse_data(max_degree, max_order, dso::Icgem::Datetime::min(), *cs)) {
      fprintf(stderr,
              "[ERROR] Failed parsing Stokes coefficients of type \'%c\' from "
              "file %s (traceback: %s)\n",
              wave_info._sinCos, wave_fn.c_str(), __func__);
      throw std::runtime_error("[ERROR] Failed parsing tidal wave sin/cos coefficients\n");
    }

    /* current max degre/orer */
    cmaxdeg = (cmaxdeg<cs->max_degree())?cs->max_degree():cmaxdeg;
    cmaxord = (cmaxord<cs->max_order())? cs->max_order():cmaxord;
  } /* done looping through files */

  /* assign atlas name */
  std::strcpy(atlas.name(), tmp_name);

  return atlas;
}
