#include "iers2010.hpp"
#include <cassert>
#include <cmath>
#include <cstdio>

// Test input and results from calling the original FORTRAN INTERP.f program
// check that the libiers versions agrees to within one microarcsecond/microsec
// [μas] and [μsec]

const double IRJD[] = {
    57204.000, 57205.000, 57206.000, 57207.000, 57207.100, 57207.200, 57207.300,
    57207.400, 57207.500, 57207.700, 57207.800, 57207.900, 57207.990, 57207.999,
    57230.123, 57236.456, 57242.789, 57243.999, 57246.111, 57264.100, 57264.200,
    57264.300, 57264.400, 57264.500, 57264.600, 57264.700, 57264.800, 57264.900,
    57264.999, 57265.000, 57265.123, 57265.456, 57265.789, 57266.000, 57266.123,
    57266.456, 57266.789};
constexpr const int tsize = sizeof(IRJD) / sizeof(double);

const double RJD[] = {
    57205.000, 57206.000, 57207.000, 57208.000, 57209.000, 57210.000, 57211.000,
    57212.000, 57213.000, 57214.000, 57215.000, 57216.000, 57217.000, 57218.000,
    57219.000, 57220.000, 57221.000, 57222.000, 57223.000, 57224.000, 57225.000,
    57226.000, 57227.000, 57228.000, 57229.000, 57230.000, 57231.000, 57232.000,
    57233.000, 57234.000, 57235.000, 57236.000, 57237.000, 57238.000, 57239.000,
    57240.000, 57241.000, 57242.000, 57243.000, 57244.000, 57245.000, 57246.000,
    57247.000, 57248.000, 57249.000, 57250.000, 57251.000, 57252.000, 57253.000,
    57254.000, 57255.000, 57256.000, 57257.000, 57258.000, 57259.000, 57260.000,
    57261.000, 57262.000, 57263.000, 57264.000, 57265.000, 57266.000};
constexpr const int isize = sizeof(RJD) / sizeof(double);

const double X[] = { // milliarcseconds
    143.585, 145.023, 146.584, 148.605, 150.878, 152.828, 154.865, 156.784,
    158.589, 160.586, 162.994, 165.661, 168.213, 170.397, 172.208, 173.805,
    175.725, 177.372, 178.863, 180.096, 181.076, 182.056, 183.044, 184.507,
    185.880, 187.311, 189.252, 191.134, 192.933, 194.603, 196.321, 198.136,
    200.125, 202.223, 204.573, 206.879, 208.670, 209.976, 210.618, 211.310,
    212.085, 212.794, 213.778, 215.354, 217.028, 218.413, 219.397, 219.890,
    219.491, 219.542, 220.088, 221.253, 222.230, 223.102, 224.084, 225.323,
    225.984, 226.099, 226.138, 225.982, 226.111, 226.169};

const double Y[] = { // milliarcseconds
    447.324, 446.640, 445.597, 444.673, 444.072, 443.816, 443.739, 443.459,
    442.769, 441.767, 440.573, 439.443, 438.468, 437.517, 436.311, 434.926,
    433.888, 432.915, 432.065, 431.333, 430.395, 429.555, 428.769, 427.851,
    426.790, 425.434, 424.096, 422.975, 421.570, 420.199, 418.686, 417.358,
    415.870, 414.629, 413.481, 412.287, 411.122, 410.047, 408.523, 406.638,
    404.949, 403.346, 401.426, 399.617, 398.037, 396.817, 395.456, 394.008,
    392.340, 390.423, 388.499, 386.445, 384.677, 382.812, 381.104, 379.135,
    377.187, 374.964, 373.275, 371.909, 370.668, 369.669};

const double UT1[] = { // milliseconds
    322.754, 322.063, 321.254, 320.237, 319.036, 317.755, 316.427, 315.103,
    313.854, 312.748, 311.827, 311.099, 310.549, 310.120, 309.719, 309.278,
    308.812, 308.341, 307.856, 307.344, 306.811, 306.296, 305.800, 305.300,
    304.877, 304.489, 304.096, 303.703, 303.239, 302.639, 301.839, 300.857,
    299.697, 298.458, 297.213, 296.038, 295.002, 294.114, 293.355, 292.703,
    292.118, 291.527, 290.888, 290.179, 289.412, 288.607, 287.768, 286.928,
    286.108, 285.285, 284.452, 283.635, 282.872, 282.116, 281.310, 280.420,
    279.454, 278.338, 277.025, 275.505, 273.802, 271.992};

struct {
  double mjd, x, y, ut1;
} results[] = {
    /* MJD             X-microarcsec  Y-microarcsec  DUT1 microsec */
    {57204.0000000000, 13552050.91493, -3535120.17239, -2692498.10487},
    {57205.0000000000, 143491.88801, 447923.97804, 322709.11837},
    {57206.0000000000, 145045.19262, 447173.26903, 322033.27843},
    {57207.0000000000, 146727.38666, 445997.70738, 321243.17297},
    {57207.1000000000, 146509.63600, 446089.84305, 321108.01776},
    {57207.2000000000, 146616.65055, 445680.82511, 321009.54022},
    {57207.3000000000, 147316.40398, 445138.10977, 320951.93899},
    {57207.4000000000, 148048.10307, 444920.43182, 320894.38650},
    {57207.5000000000, 148125.36090, 445023.27498, 320800.49071},
    {57207.7000000000, 147349.50732, 444778.41912, 320567.04566},
    {57207.8000000000, 147762.63781, 444480.27959, 320475.42833},
    {57207.9000000000, 148498.81102, 444537.39209, 320376.74246},
    {57207.9900000000, 148841.21876, 444866.98171, 320258.41359},
    {57207.9990000000, 148848.06892, 444901.91028, 320245.07813},
    {57230.1230000000, 187781.58767, 425221.89198, 304431.73588},
    {57236.4560000000, 199717.81752, 416559.33689, 300372.76338},
    {57242.7890000000, 210379.79310, 409142.68668, 293485.01635},
    {57243.9990000000, 211173.86202, 406914.93456, 292660.03387},
    {57246.1110000000, 212737.47943, 403298.31879, 291419.20040},
    {57264.1000000000, 225492.31288, 372180.39233, 275293.98067},
    {57264.2000000000, 225677.25825, 371595.44123, 275147.40308},
    {57264.3000000000, 226376.25492, 371188.89436, 275022.46782},
    {57264.4000000000, 226723.93210, 371259.21508, 274868.84814},
    {57264.5000000000, 226266.76238, 371469.57901, 274674.18082},
    {57264.6000000000, 225574.94457, 371318.46750, 274478.18986},
    {57264.7000000000, 225514.83468, 370821.19236, 274318.58246},
    {57264.8000000000, 226127.39048, 370493.92430, 274180.35023},
    {57264.9000000000, 226588.72691, 370659.98526, 274015.49841},
    {57264.9990000000, 226311.54042, 370999.96661, 273809.33157},
    {57265.0000000000, 226305.62773, 371002.21929, 273807.12676},
    {57265.1230000000, 225611.00203, 370876.79526, 273548.41053},
    {57265.4560000000, 226761.69059, 370198.45466, 273003.41648},
    {57265.7890000000, 226028.82503, 369520.57578, 272383.18699},
    {57266.0000000000, 12585418.63244, 16952021.95524, -3174413.46254},
    {57266.1230000000, 225765.01269, 369887.18724, 271748.91693},
    {57266.4560000000, 226623.69401, 369270.93772, 271172.44368},
    {57266.7890000000, 225669.34470, 368938.79856, 270520.75357},
};
constexpr const int sz = sizeof(results) / sizeof(results[0]);
static_assert(sz == tsize);

int main() {
  double xint, yint, ut1int;
  for (int i = 0; i < sz; i++) {
    int status = iers2010::interp_pole(RJD, X, Y, UT1, isize, IRJD[i], xint,
                                       yint, ut1int);
    // note! results from interp_pole are in mas and ms
    if (status > 0) {
      fprintf(stderr,
              "Failed interpolating for MJD=%.3f; Input values span interval: "
              "%.3f to %.3f\n",
              IRJD[i], RJD[0], RJD[isize - 1]);
    } else if (status < 0) {
      fprintf(stderr,
              "Value computed (interpolated) but too close to "
              "limits!\ninterpolating for MJD=%.3f; Input values span "
              "interval: %.3f to %.3f\n",
              IRJD[i], RJD[0], RJD[isize - 1]);
    }
    if (status <= 0) {
      printf("MJD=%.5f\n%+10.3f %+10.3f %+10.3f[microarcsec]\n%+10.3f %+10.3f "
             "%+10.3f[microarcsec]\n",
             IRJD[i], xint * 1e3, yint * 1e3, ut1int * 1e3, results[i].x,
             results[i].y, results[i].ut1);
      assert(std::abs(IRJD[i] - results[i].mjd) < 1e-13);
      assert(std::abs(xint * 1e3 - results[i].x) < 1e0);
      assert(std::abs(yint * 1e3 - results[i].y) < 1e0);
      assert(std::abs(ut1int * 1e3 - results[i].ut1) < 1e0);
    }
  }

  return 0;
}
